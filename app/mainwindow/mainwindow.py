import re
import sys
from PySide6.QtCore import Qt, QFile, Slot
from PySide6.QtGui import QBrush, QColor, QFont
from PySide6.QtWidgets import QApplication, QMainWindow, QGridLayout, QWidget, QColorDialog, QListWidgetItem, \
    QVBoxLayout, QListWidget, QSizePolicy, QFileDialog

from app.widgets.addfontcard import AddFontCard
from app.widgets.colordisplaywidget import ColorDisplayWidget
from app.mainwindow.ui_mainwindow import Ui_MainWindow
from app.widgets.fontcard import FontCard
from app.widgets.settingsitemwidget import SettingItemWidget
from qtpop import QtPop, debug_log
from qtpop.configuration.models import SettingItem


# generated by pyside6-uic

class MainWindow(QMainWindow):
    def __init__(self, qt_pop: QtPop):
        super().__init__()
        self.qt_pop = qt_pop
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.setWindowTitle(self.qt_pop.config.get_value('name'))
        self.load_ui()

        self.qt_pop.log.info("MainWindow initialized successfully.")
        self.qt_pop.data.broadcast_message("main_window_opened", True)

    def load_ui(self):
        self.setup_logging()
        self.setup_palette()
        self.setup_settings()
        self.setup_qss()
        self.setup_fonts()

        self.apply_style()

        # self.ui.saveBtn.clicked.disconnect() if hasattr(self.ui.saveBtn, "clicked") else None
        self.ui.saveBtn.clicked.connect(self.save_settings)


    @debug_log
    def setup_palette(self):
        def load_palette():
            grid = QGridLayout()
            grid.setSpacing(5)
            grid.setContentsMargins(5, 5, 5, 5)
            columns = 5

            for i, (item, hex_val) in enumerate(self.qt_pop.style.colour_map().items()):
                row = i // columns
                col = i % columns
                grid.addWidget(ColorDisplayWidget(hex_val, item), row, col)

            old_layout = self.ui.p_frame.layout()
            if old_layout is not None:
                QWidget().setLayout(old_layout)

            self.ui.p_frame.setLayout(grid)
        load_palette()

    @debug_log
    def setup_settings(self):
        toolbox = self.ui.settingsTB
        while toolbox.count() > 0:
            toolbox.removeItem(0)  # clear existing pages

        # --- Group user settings by 'group' ---
        grouped_settings = {}
        for key, item in self.qt_pop.config.data.configuration.user.items():
            grouped_settings.setdefault(item.group, []).append(item)

        # --- Create a QListWidget per group ---
        for group_name, items in grouped_settings.items():
            list_widget = QListWidget()
            list_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

            for item in items:
                self.qt_pop.log.info(f"Loading setting {item.name}, value: {item.value}")
                custom_widget = SettingItemWidget(item)
                list_item = QListWidgetItem(list_widget)
                hint = custom_widget.sizeHint()
                hint.setHeight(hint.height() + 10)
                list_item.setSizeHint(hint)
                list_widget.addItem(list_item)
                list_widget.setItemWidget(list_item, custom_widget)

            toolbox.addItem(list_widget, group_name)

        # --- Add static settings page ---
        static_widget = QListWidget()
        for key, value in self.qt_pop.config.data.configuration.static.items():
            self.qt_pop.log.info(f"Loading static setting {key}, value: {value}")
            item = SettingItem(key, key, value, [], "Application static setting", "text", "user", "Static", "")
            custom_widget = SettingItemWidget(item)
            list_item = QListWidgetItem(static_widget)
            hint = custom_widget.sizeHint()
            hint.setHeight(hint.height() + 10)
            list_item.setSizeHint(hint)
            static_widget.addItem(list_item)
            static_widget.setItemWidget(list_item, custom_widget)

        toolbox.addItem(static_widget, "Static Settings")

        icon_color = self.qt_pop.style.get_colour('accent')
        for i in range(toolbox.count()):
            toolbox.setItemIcon(i, self.qt_pop.icon.get_pixmap("action", icon_color))

        # --- Connect save button ---

    def apply_style(self):
        accent = self.qt_pop.config.get_value('accent')
        support = self.qt_pop.config.get_value('support')
        neutral = self.qt_pop.config.get_value('neutral')
        theme = self.qt_pop.config.get_value('theme')
        self.qt_pop.style.initialise(accent.value, support.value, neutral.value, theme.value)

        qss = self.ui.cqss.toPlainText()
        translated_qss = self.qt_pop.qss.process(qss)
        self.setStyleSheet(translated_qss)
        self.setPalette(self.qt_pop.style.get_palette())


    @Slot()
    @debug_log
    def save_settings(self):
        toolbox = self.ui.settingsTB

        for i in range(toolbox.count()):
            page_widget = toolbox.widget(i)
            group_name = toolbox.itemText(i)

            # Iterate through each QListWidgetItem in the page
            for row in range(page_widget.count()):
                list_item = page_widget.item(row)
                custom_widget = page_widget.itemWidget(list_item)
                if not custom_widget:
                    continue

                # Assuming SettingItemWidget has `item` and `get_value()` methods
                setting_item = custom_widget.item
                new_value = setting_item.value # e.g., from QLineEdit, ComboBox, etc.
                self.qt_pop.config.set_value(setting_item.shortname, new_value)
                setting_item.value = new_value  # update local copy

        # Optionally persist configuration to disk
        if hasattr(self.qt_pop.config, "save"):
            self.qt_pop.config.save()

        self.qt_pop.log.info("All settings saved successfully.")

        self.apply_style()
        self.load_ui()

    @debug_log
    def setup_logging(self):
        ansi_regex = re.compile(r'\x1b\[(?:38;5;(\d{1,3})|9[0-7]|3[0-7]|0)m')

        def ansi_to_hex(match):
            """Convert ANSI escape match to hex color."""
            code = match.group(1)
            if code is not None:
                # 256-color mode
                code = int(code)
                return ansi256_to_hex(code)
            else:
                # 16-color / classic ANSI
                ansi_code = match.group(0)
                return ansi16_to_hex(ansi_code)

        def ansi16_to_hex(code):
            """16-color ANSI mapping"""
            mapping = {
                "\x1b[30m": "#000000",
                "\x1b[31m": "#FF0000",
                "\x1b[32m": "#00FF00",
                "\x1b[33m": "#FFFF00",
                "\x1b[34m": "#0000FF",
                "\x1b[35m": "#FF00FF",
                "\x1b[36m": "#00FFFF",
                "\x1b[37m": "#FFFFFF",
                "\x1b[90m": "#808080",
                "\x1b[91m": "#FF5555",
                "\x1b[92m": "#55FF55",
                "\x1b[93m": "#FFFF55",
                "\x1b[94m": "#5555FF",
                "\x1b[95m": "#FF55FF",
                "\x1b[96m": "#55FFFF",
                "\x1b[97m": "#FFFFFF",
                "\x1b[0m": "#FFFFFF",  # reset
            }
            return mapping.get(code, "#FFFFFF")

        def ansi256_to_hex(code: int) -> str | None:
            """Convert 256-color ANSI code (0-255) to hex string."""
            if code < 16:
                # standard colors
                standard = [
                    0x000000, 0x800000, 0x008000, 0x808000, 0x000080, 0x800080, 0x008080, 0xc0c0c0,
                    0x808080, 0xff0000, 0x00ff00, 0xffff00, 0x0000ff, 0xff00ff, 0x00ffff, 0xffffff
                ]
                return f"#{standard[code]:06X}"
            elif 16 <= code <= 231:
                code -= 16
                r = (code // 36) * 51
                g = ((code % 36) // 6) * 51
                b = (code % 6) * 51
                return f"#{r:02X}{g:02X}{b:02X}"
            elif 232 <= code <= 255:
                gray = (code - 232) * 10 + 8
                return f"#{gray:02X}{gray:02X}{gray:02X}"
            return None

        def strip_ansi_codes(text):
            """Remove ANSI codes but keep the color info for HTML."""
            return ansi_regex.sub("", text)

        def on_log(timestamp, msg, level, color):
            # Convert color ANSI to hex
            hex_color = ansi16_to_hex(color) if not color.startswith("\x1b[38;5;") else ansi256_to_hex(int(color[7:-1]))
            # Strip all ANSI codes from message
            clean_msg = strip_ansi_codes(msg)
            html_msg = f'<span style="color:{hex_color};"><b> | {level} | </b> {timestamp} | {clean_msg}</span>'
            self.ui.logTB.append(html_msg)
            # self.ui.logTB.moveCursor(self.ui.logTB.textCursor().atEnd())

        self.qt_pop.log.signal.disconnect() if hasattr(self.qt_pop.log.signal, "signal") else None
        self.qt_pop.log.signal.connect(on_log)

        self.qt_pop.log.info("Running log test messages...")
        self.qt_pop.log.warning("This is a warning message.")
        self.qt_pop.log.error("This is an error message.")
        self.qt_pop.log.info("This is an info message.")
        self.qt_pop.log.debug("This is a debug message.")
        self.qt_pop.log.critical("This is a critical message.")

    def setup_qss(self):
        """Setup QSS editor with load and apply buttons."""
        qss_path = self.qt_pop.config.get_value('qss_path')
        file = QFile(qss_path.value)
        default_qss = ""

        if file.open(QFile.ReadOnly | QFile.Text):
            default_qss = file.readAll().data().decode("utf-8")
            file.close()

        # Set initial QSS in code editor
        self.ui.cqss.setText(default_qss)

        # Process and apply default QSS
        translated_qss = self.qt_pop.qss.process(default_qss)
        self.ui.tqss.setText(translated_qss)
        self.qt_pop.qss.set_style(translated_qss)

        # ---- Button Connections ----
        def on_apply_clicked():
            """Apply QSS from cqss."""
            raw_qss = self.ui.cqss.toPlainText()
            translated = self.qt_pop.qss.process(raw_qss)
            self.ui.tqss.setText(translated)
            self.setStyleSheet(translated)
            self.qt_pop.log.info("Applied translated QSS.")

        def on_load_clicked():
            """Load QSS file into cqss."""
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Open QSS File",
                "",
                "QSS Files (*.qss);;All Files (*)"
            )
            if not file_path:
                return
            with open(file_path, "r", encoding="utf-8") as f:
                qss_content = f.read()
            self.ui.cqss.setText(qss_content)
            self.qt_pop.log.info(f"Loaded QSS file: {file_path}")

        # Connect buttons
        # self.ui.applybtn.clicked.disconnect()
        # self.ui.loadbtn.clicked.disconnect() if hasattr(self.ui.loadbtn, "clicked") else None
        self.ui.applybtn.clicked.connect(on_apply_clicked)
        self.ui.loadbtn.clicked.connect(on_load_clicked)

    def resizeEvent(self, event, /):
        super().resizeEvent(event)
        self.ui.statusbar.showMessage(f"{self.width()} x {self.height()}")

    def setup_fonts(self):
        # Load defaults
        self.qt_pop.font.load_font("resources/fonts/RobotoCondensed-VariableFont_wght.ttf", "h1", 18)
        self.qt_pop.font.load_font("resources/fonts/RobotoCondensed-VariableFont_wght.ttf", "h2", 14)
        self.qt_pop.font.load_font("resources/fonts/Roboto-VariableFont_wdth,wght.ttf", "p", 11)
        self.qt_pop.font.load_font("resources/fonts/RobotoCondensed-VariableFont_wght.ttf", "pc", 11)
        self.qt_pop.font.load_font("resources/fonts/Inconsolata-VariableFont_wdth,wght.ttf", "log", 11)

        lw = self.ui.fontLW
        lw.clear()
        lw.setSpacing(6)

        # --- Add new font card at bottom ---
        add_card = AddFontCard(self.qt_pop.font.load_font)
        add_item = QListWidgetItem(lw)
        hint = add_card.sizeHint()
        hint.setHeight(hint.height() + 20)
        add_item.setSizeHint(hint)
        lw.addItem(add_item)
        lw.setItemWidget(add_item, add_card)

        font_map = self.qt_pop.font.get_font_map()
        for tag, info in font_map.items():
            card = FontCard(info['family'], tag, info['size'], self.set_application_font)
            item = QListWidgetItem(lw)
            hint = card.sizeHint()
            hint.setHeight(hint.height() + 10)
            item.setSizeHint(hint)
            lw.addItem(item)
            lw.setItemWidget(item, card)



        self.set_application_font("pc")

    def set_application_font(self, tag: str, size = None):
        """Sets the application-wide font."""
        font = self.qt_pop.font.get_font(tag)
        if size is not None:
            font.setPointSize(size)
        app = QApplication.instance()
        app.setFont(font)
        self.apply_style()